pipeline {
    agent any

    environment {
        // Configuration Docker
        DOCKER_REG = ''
        BACKEND_IMAGE = 'transport-backend'
        FRONTEND_IMAGE = 'transport-frontend'
        IMAGE_TAG = "${BUILD_NUMBER}"

        // Configuration Kubernetes
        CLUSTER_NAME = 'k8s-terraform'
        KUBECONFIG = "${WORKSPACE}/.kube/config"

        // Chemins
        GIT_EXEC = 'C:\\Program Files\\Git\\cmd\\git.exe'
        DOCKER_EXEC = 'C:\\Program Files\\Docker\\Docker\\resources\\bin\\docker.exe'
    }

    stages {
        stage('Setup Credentials') {
            steps {
                script {
                    // Charger les credentials si ils existent
                    try {
                        withCredentials([
                            string(credentialsId: 'ors-api-key', variable: 'ORS_KEY'),
                            string(credentialsId: 'tomtom-api-key', variable: 'TOMTOM_KEY')
                        ]) {
                            env.ORS_API_KEY = env.ORS_KEY
                            env.TOMTOM_API_KEY = env.TOMTOM_KEY
                            echo "Credentials loaded successfully"
                        }
                    } catch (Exception e) {
                        echo "Warning: Could not load credentials: ${e.message}"
                        echo "Using default values"
                        env.ORS_API_KEY = "eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6IjIwNjAxYzVlZmFlNjQ1OGZiOTY3ODUxNDg3NTY2MjBlIiwiaCI6Im11cm11cjY0In0="
                        env.TOMTOM_API_KEY = "YOUR_TOMTOM_API_KEY"
                    }
                }
            }
        }

        stage('Checkout SCM') {
            steps {
                echo "[INFO] Checking out code from Git"
                script {
                    checkout scm
                    env.COMMIT_SHORT = bat(
                        script: "\"${GIT_EXEC}\" rev-parse --short HEAD",
                        returnStdout: true
                    ).trim()
                    echo "Current commit: ${env.COMMIT_SHORT}"
                }
            }
        }

        stage('Environment Check') {
            steps {
                echo "[INFO] Checking environment"
                bat """
                    echo Git version:
                    "${GIT_EXEC}" --version

                    echo Docker version:
                    "${DOCKER_EXEC}" --version

                    echo Kubectl version:
                    kubectl version --client

                    echo Terraform version:
                    terraform version

                    echo Kind version:
                    kind version
                """
            }
        }

        stage('Validate Terraform') {
            steps {
                echo "[INFO] Validating Terraform configuration"
                dir('infrastructure/Terraform') {
                    bat """
                        terraform init
                        terraform validate
                    """
                }
            }
        }

        stage('Build Backend Image') {
            steps {
                echo "[INFO] Building backend Docker image"
                bat """
                    "${DOCKER_EXEC}" build ^
                        -f backend/Dockerfile ^
                        -t ${BACKEND_IMAGE}:latest ^
                        -t ${BACKEND_IMAGE}:${IMAGE_TAG} ^
                        .
                """
            }
        }

        stage('Build Frontend Image') {
            steps {
                echo "[INFO] Building frontend Docker image"
                bat """
                    "${DOCKER_EXEC}" build ^
                        -f frontend/Dockerfile ^
                        -t ${FRONTEND_IMAGE}:latest ^
                        -t ${FRONTEND_IMAGE}:${IMAGE_TAG} ^
                        .
                """
            }
        }

        stage('Create or Update Kind Cluster') {
            steps {
                echo "[INFO] Managing Kind cluster"
                script {
                    def clusterExists = bat(
                        script: "kind get clusters 2>nul | findstr ${CLUSTER_NAME}",
                        returnStatus: true
                    ) == 0

                    if (clusterExists) {
                        echo "Cluster ${CLUSTER_NAME} already exists"
                    } else {
                        echo "Creating cluster ${CLUSTER_NAME}"
                        bat """
                            kind create cluster ^
                                --name ${CLUSTER_NAME} ^
                                --config infrastructure/kind/cluster-config.yaml ^
                                --wait 5m
                        """
                    }
                    bat "kind export kubeconfig --name ${CLUSTER_NAME}"
                }
            }
        }

        stage('Load Images to Kind') {
            steps {
                echo "[INFO] Loading Docker images to Kind cluster"
                bat """
                    kind load docker-image ${BACKEND_IMAGE}:latest --name ${CLUSTER_NAME}
                    kind load docker-image ${FRONTEND_IMAGE}:latest --name ${CLUSTER_NAME}
                """
            }
        }

        stage('Deploy with Terraform') {
            steps {
                echo "[INFO] Deploying infrastructure with Terraform"
                dir('infrastructure/Terraform') {
                    bat """
                        terraform plan -out=tfplan
                        terraform apply -auto-approve tfplan
                        terraform output
                    """
                }
            }
        }

        stage('Wait for Deployments') {
            steps {
                echo "[INFO] Waiting for pods to be ready"
                bat """
                    kubectl wait --for=condition=ready pod -l app=redis --timeout=120s
                    kubectl wait --for=condition=ready pod -l app=backend --timeout=120s
                    kubectl wait --for=condition=ready pod -l app=frontend --timeout=120s
                """
            }
        }

        stage('Verify Deployment') {
            steps {
                echo "[INFO] Verifying deployment"
                bat """
                    echo ========================================
                    echo Deployments Status:
                    kubectl get deployments
                    
                    echo ========================================
                    echo Services Status:
                    kubectl get services
                    
                    echo ========================================
                    echo Pods Status:
                    kubectl get pods -o wide
                    
                    echo ========================================
                    echo Backend Logs:
                    kubectl logs -l app=backend --tail=20
                """
            }
        }

        stage('Display Access Info') {
            steps {
                echo "[INFO] Application access information"
                script {
                    def nodeIP = bat(
                        script: 'kubectl get nodes -o jsonpath="{.items[0].status.addresses[?(@.type==\\"InternalIP\\")].address}"',
                        returnStdout: true
                    ).trim()
                    
                    echo """
                    ========================================
                    Deployment Successful!
                    ========================================
                    Frontend: http://${nodeIP}:30001
                    Backend:  http://${nodeIP}:30002
                    Health:   http://${nodeIP}:30002/health
                    
                    For local access, run:
                    kubectl port-forward svc/frontend-service 8080:80
                    kubectl port-forward svc/backend-service 8000:3000
                    
                    Then access:
                    Frontend: http://localhost:8080
                    Backend:  http://localhost:8000
                    ========================================
                    """
                }
            }
        }
    }

    post {
        always {
            script {
                try {
                    echo "[INFO] Cleaning up"
                    bat """
                        "${env.DOCKER_EXEC}" system prune -f || exit 0
                        if exist infrastructure\\Terraform\\tfplan del infrastructure\\Terraform\\tfplan
                    """
                } catch (Exception e) {
                    echo "Cleanup failed: ${e.message}"
                }
            }
        }

        success {
            script {
                echo "[SUCCESS] Pipeline completed successfully!"
                try {
                    def nodeIP = bat(
                        script: 'kubectl get nodes -o jsonpath="{.items[0].status.addresses[?(@.type==\\"InternalIP\\")].address}"',
                        returnStdout: true
                    ).trim()
                    currentBuild.description = "Build: ${BUILD_NUMBER} | Commit: ${env.COMMIT_SHORT} | Frontend: http://${nodeIP}:30001"
                } catch (Exception e) {
                    echo "Could not set build description: ${e.message}"
                }
            }
        }

        failure {
            script {
                echo "[ERROR] Pipeline failed!"
                try {
                    bat """
                        kubectl get pods > pod-status.log 2>&1 || exit 0
                        kubectl describe pods >> pod-status.log 2>&1 || exit 0
                        kubectl logs -l app=backend --tail=50 > backend-logs.log 2>&1 || exit 0
                        kubectl logs -l app=frontend --tail=50 > frontend-logs.log 2>&1 || exit 0
                    """
                    archiveArtifacts artifacts: '*.log', allowEmptyArchive: true
                } catch (Exception e) {
                    echo "Could not collect failure logs: ${e.message}"
                }
            }
        }
    }
}