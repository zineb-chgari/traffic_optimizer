pipeline {
    agent any

    options {
        timeout(time: 30, unit: 'MINUTES')
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '10'))
    }

    environment {
        // Étendre le PATH au lieu de l'écraser
        PATH = "C:\\Program Files\\Docker\\Docker\\resources\\bin;C:\\ProgramData\\chocolatey\\bin;${env.PATH}"
        
        BACKEND_IMAGE = "transport-backend"
        FRONTEND_IMAGE = "transport-frontend"
        IMAGE_TAG = "${BUILD_NUMBER}"
        CLUSTER_NAME = "k8s-terraform"
        // Utiliser le kubeconfig par défaut de l'utilisateur
        KUBECONFIG = "${env.USERPROFILE}\\.kube\\config"
    }

    stages {

        stage('Checkout SCM') {
            steps {
                checkout scm
            }
        }

        stage('Environment Check') {
            steps {
                script {
                    echo '=== Validating Required Tools ==='
                    
                    def tools = [
                        'docker': 'docker --version',
                        'kubectl': 'kubectl version --client',
                        'terraform': 'terraform version',
                        'kind': 'kind version'
                    ]
                    
                    tools.each { name, command ->
                        def status = bat(script: command, returnStatus: true)
                        if (status != 0) {
                            error("${name} is not installed or not accessible in PATH")
                        }
                        echo "✓ ${name} found"
                    }
                }
            }
        }

        stage('Validate Terraform') {
            steps {
                dir('infrastructure\\Terraform') {
                    bat '''
                    if exist terraform.tfstate del /f terraform.tfstate
                    if exist terraform.tfstate.backup del /f terraform.tfstate.backup
                    if exist .terraform\\terraform.tfstate del /f .terraform\\terraform.tfstate
                    terraform init -reconfigure -input=false
                    terraform validate
                    '''
                }
            }
        }

        stage('Build Images') {
            parallel {
                stage('Build Backend') {
                    steps {
                        bat "docker build -f backend\\Dockerfile -t ${BACKEND_IMAGE}:latest -t ${BACKEND_IMAGE}:${IMAGE_TAG} backend"
                    }
                }
                stage('Build Frontend') {
                    steps {
                        bat "docker build -f frontend\\Dockerfile -t ${FRONTEND_IMAGE}:latest -t ${FRONTEND_IMAGE}:${IMAGE_TAG} frontend"
                    }
                }
            }
        }

        stage('Setup Kind Cluster') {
            steps {
                script {
                    echo '=== Setting up Kind Cluster ==='
                    
                    // Méthode plus fiable : vérifier directement avec kubectl
                    def clusterHealthy = bat(
                        script: "kubectl cluster-info --context kind-${CLUSTER_NAME} 2>nul",
                        returnStatus: true
                    ) == 0
                    
                    if (clusterHealthy) {
                        echo "✓ Cluster ${CLUSTER_NAME} is healthy, reusing it"
                        bat "kubectl config use-context kind-${CLUSTER_NAME}"
                        
                        // CRITIQUE : Forcer Terraform à utiliser le bon kubeconfig
                        echo "Refreshing kubeconfig for Terraform..."
                        bat "kind export kubeconfig --name ${CLUSTER_NAME}"
                        return
                    }
                    
                    // Si le cluster n'est pas sain, vérifier s'il existe quand même
                    echo "Cluster not healthy or not found, checking for remnants..."
                    
                    def clusterListed = bat(
                        script: """
                            @echo off
                            kind get clusters > clusters.tmp 2>nul
                            findstr /X "${CLUSTER_NAME}" clusters.tmp >nul 2>&1
                            set RESULT=%ERRORLEVEL%
                            del clusters.tmp 2>nul
                            exit /b %RESULT%
                        """,
                        returnStatus: true
                    ) == 0
                    
                    if (clusterListed) {
                        echo "Cluster exists but is unhealthy, deleting..."
                        bat "kind delete cluster --name ${CLUSTER_NAME}"
                        bat "timeout /t 5 /nobreak >nul"
                    }
                    
                    // Nettoyer les contextes kubectl obsolètes
                    echo "Cleaning stale kubectl contexts..."
                    bat """
                        kubectl config delete-context kind-${CLUSTER_NAME} 2>nul || exit 0
                        kubectl config delete-cluster kind-${CLUSTER_NAME} 2>nul || exit 0
                    """
                    
                    // Nettoyer les conteneurs orphelins Docker
                    echo "Cleaning any orphaned Docker containers..."
                    bat """
                        @echo off
                        for /f "tokens=*" %%i in ('docker ps -aq --filter "label=io.x-k8s.kind.cluster=${CLUSTER_NAME}" 2^>nul') do (
                            echo Removing orphaned container: %%i
                            docker rm -f %%i 2>nul
                        )
                    """
                    
                    // Créer le cluster
                    echo "Creating new Kind cluster..."
                    bat "kind create cluster --name ${CLUSTER_NAME} --wait 120s"
                    
                    // Exporter le kubeconfig pour s'assurer que tout est à jour
                    echo "Exporting fresh kubeconfig..."
                    bat "kind export kubeconfig --name ${CLUSTER_NAME}"
                    
                    // Vérifier la création
                    def created = bat(
                        script: "kubectl cluster-info --context kind-${CLUSTER_NAME}",
                        returnStatus: true
                    ) == 0
                    
                    if (!created) {
                        error("Failed to create functional Kind cluster")
                    }
                    
                    echo "✓ Cluster created successfully"
                }
            }
        }

        stage('Verify Cluster') {
            steps {
                bat '''
                echo === Verifying Cluster Connectivity ===
                kubectl config use-context kind-%CLUSTER_NAME%
                kubectl cluster-info
                kubectl wait --for=condition=Ready nodes --all --timeout=180s
                kubectl get nodes
                echo ✓ Cluster is ready
                '''
            }
        }

        stage('Load Images to Kind') {
            steps {
                bat '''
                echo === Loading Docker Images ===
                kind load docker-image %BACKEND_IMAGE%:latest --name %CLUSTER_NAME%
                kind load docker-image %FRONTEND_IMAGE%:latest --name %CLUSTER_NAME%
                echo ✓ Images loaded successfully
                '''
            }
        }

        stage('Deploy with Terraform') {
            steps {
                dir('infrastructure\\Terraform') {
                    bat '''
                    echo === Deploying with Terraform ===
                    kubectl config use-context kind-%CLUSTER_NAME%
                    
                    echo Current kubectl context:
                    kubectl config current-context
                    
                    echo Kubernetes API endpoint:
                    kubectl config view --minify -o jsonpath="{.clusters[0].cluster.server}"
                    echo.
                    
                    terraform init -reconfigure -input=false
                    terraform apply -auto-approve -refresh=true
                    echo ✓ Terraform deployment completed
                    '''
                }
            }
        }

        stage('Wait for Pods') {
            steps {
                script {
                    echo '=== Waiting for Pods to be Ready ==='
                    
                    def components = ['redis', 'backend', 'frontend']
                    
                    components.each { component ->
                        echo "Waiting for ${component} pods..."
                        
                        def status = bat(
                            script: "kubectl wait --for=condition=Ready pod -l app=${component} --timeout=300s",
                            returnStatus: true
                        )
                        
                        if (status != 0) {
                            error("${component} pods failed to become ready within timeout")
                        }
                        
                        echo "✓ ${component} pods are ready"
                    }
                }
            }
        }

        stage('Verify Deployment') {
            steps {
                bat '''
                echo === Deployment Status ===
                echo.
                echo [Pods]
                kubectl get pods -o wide
                echo.
                echo [Services]
                kubectl get svc
                echo.
                echo [Deployments]
                kubectl get deployments
                echo.
                echo === Recent Logs ===
                kubectl logs -l app=backend --tail=10 --all-containers=true || echo No backend logs
                kubectl logs -l app=frontend --tail=10 --all-containers=true || echo No frontend logs
                '''
            }
        }
    }

    post {
        always {
            echo "Cleaning up Docker resources..."
            bat "docker system prune -f || exit 0"
        }
        success {
            echo """
            ==========================================
            ✓ DEPLOYMENT SUCCESSFUL
            ==========================================
            
            Access your application:
              Frontend: http://localhost:30001
              Backend:  http://localhost:30002
            
            Useful commands:
              kubectl get pods
              kubectl logs -l app=backend -f
              kubectl logs -l app=frontend -f
            
            Cluster: ${CLUSTER_NAME}
            ==========================================
            """
        }
        failure {
            bat '''
                echo ==========================================
                echo ✗ DEPLOYMENT FAILED - DEBUG INFO
                echo ==========================================
                echo.
                kubectl get pods -A || echo Cannot retrieve pods
                echo.
                kubectl get events --sort-by=.metadata.creationTimestamp || echo Cannot retrieve events
                echo.
                kubectl describe pods -l app=backend || echo No backend pods
                kubectl describe pods -l app=frontend || echo No frontend pods
                echo.
                echo To clean up: kind delete cluster --name %CLUSTER_NAME%
                echo ==========================================
            '''
        }
    }
}